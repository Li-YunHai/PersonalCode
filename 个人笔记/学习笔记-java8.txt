	JVM：
	栈：
	堆：垃圾回收区、永久区、方法区
          方法区：永久区的一部分，用于存放类信息，几乎不会被垃圾回收机制回收，回收条件很苛刻。
           Java8：java8之后作废了永久区，方法区升级为元空间（MetaSpace）,元空间直接使用物理内存。
		
java8新特性：
	1、速度更快：HashMap底层采用红黑树存储、ConcurrentHashMap采用CAS自旋算法
	2、代码更少：Lambda表达式
	3、强大的Stream Api
	4、最大化减少空指针异常：Optional容器类
	5、便于并行

hashMap: 
	数组+链表   -》  数组+链表+红黑树
	链表加载因子：当元素到达现有数组的75%时，对数组进行扩容。
	红黑树转换：链表长度大于8 或 总容量大于64的时候，将链表转换成红黑树。
	java8中分布策略优化：
		1、数组长度始终保持为2的N次幂：为了在计算元素索引时进行优化
		2、将hash值得高位参与运算
		3、通过位与操作等价取模操作

concurrentHashMap:
	数据结构：Segment<K,V>数组  +  HashEntry<K,V>数组
	并发级别级别（concurrentLevel）：16
		java7：16，16个分段锁        java8：CAS自旋算法
	写操作： ConcurrentHashMap 所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，
	             当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率。
	读操作：ConcurrentHashMap在读取的大多数时候都没有用到锁定，所以读取操作几乎是完全的并发操作，而写操作锁定的粒度又非常细，比起之前又更加快速。
	
	注意：在求size等操作时才需要锁定整个表。而在迭代时，ConcurrentHashMap使用了不同于传统集合的快速失败迭代器的另一种迭代方式，称为弱一致迭代器。
	         在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据，
                         iterator完成后再将头指针替换为新的数据，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。
	
	size操作：因为在累加 count 操作过程中，之前累加过的 count 发生变化的几率非常小，所以ConcurrentHashMap 的做法是先尝试 2 次通过不锁住 Segment 的方式来统计各个 Segment 大小，
	               如果统计的过程中，容器的 count 发生了变化，则再采用加锁的方式来统计所有 Segment 的大小。在 put , remove 和 clean 方法里操作元素前都会将变量 modCount 进行加 1 ，
	               那么在统计 size 前后比较 modCount 是否发生变化，从而得知容器的大小是否发生变化。

Lambda表达式：lambda是一个匿名函数，我们可以将lambda表达式理解为一段可以传递的代码（将代码像数据一样传递）  
             操作符：->
	左侧：表达式的参数列表
	右侧：表达式所需要执行的功能，即Lambda体
       函数式接口：只有一个接口的抽象方法


Consumer<T> :  消费型接口
           void apply(T t);
Supplier<T>    :  供给型接口
           T get();

Function<T,R> :  函数型接口
           R apply(T t);

Predicate<T>   :  断言型接口
           boolean test(T t);

/*
 * 一、Stream API 的操作步骤：
 *
 * 1. 创建 Stream
 *
 * 2. 中间操作
 *    筛选与切片
 * 		filter——接收 Lambda ， 从流中排除某些元素。
 *		limit——截断流，使其元素不超过给定数量。
 *		skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补
 *		distinct——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素
 *    映射
 *		map——接收 Lambda ， 将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。
 *		flatMap——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流
 *    排序
 *	    	sorted()——自然排序
 *		sorted(Comparator com)——定制排序
 *
 * 3. 终止操作(终端操作)
 *    查找与匹配
 *      		allMatch——检查是否匹配所有元素
 *		anyMatch——检查是否至少匹配一个元素
 *		noneMatch——检查是否没有匹配的元素
 *		findFirst——返回第一个元素
 *		findAny——返回当前流中的任意元素
 *		count——返回流中元素的总个数
 *		max——返回流中最大值
 *		min——返回流中最小值
 *    归约
 *		reduce(T identity, BinaryOperator) / reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。
 *    收集
 *	   	 collect——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法
 *
 *    注意：流进行了终止操作后，不能再次使用
 */


Fork/Join框架与传统线程池的区别：
	Fork/Join采用“工作窃取”模式（worl-stealing）：当执行新的任务时它可以将其拆分成更小的任务执行，并将小任务添加
          线程队列中，然后再从一个随机线程的队列的末尾偷取一个小任务并把它放在自己的队列中。
	相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上，在一般的线程池中，如果一个线程正在
         执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态。而在fork/join框架实现中，如果某个子问题由于等待另外一个子
         问题的完成而无法继续运行，那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行，这种方式减少了线程的等待时间，提高了性能。

接口中的默认方法：
	接口默认方法的”类优先”原则，若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时
          选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。
	接口冲突：如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），
          那么必须覆盖该方法来解决冲突

日期：
	java7：日期可变，线程不安全，使用不灵活。   可使用ThreadLocal线程锁解决
	java8：日期不可变，线程安全，使用更灵活
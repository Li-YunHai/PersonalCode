设计模式的七大原则有：
	1、单一职责原则：一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2，当职责1需求变更而改变类A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2。
	2、接口隔离原则：
	3、依赖倒置原则
	4、里氏替换原则
	5、开闭原则
	6、迪米特法则
	7、合成复用原则

工厂模式：
	简单工厂：一个工厂根据类型生产不同的产品（功能单一）
	工厂方法：根据类型构建不同的工厂，每个工厂生产指定类型的产品（功能单一）
	抽象工厂：根据类型构建不同的工厂，每个工厂生产指定类型的产品（多功能）
	使用实例：Calendar类中的Calendar.getInstance()方法会根据不同的时区、地区，创建不同的Calendar实例

原型模式：用户对象拷贝，减少资源消耗。
	浅拷贝：原始属性拷贝时，进行值传递，也就是将属性值复制一份新的。引用属性拷贝时，进行引用传递，只是将对象的地址复制给了新对象。
	深拷贝：原始属性拷贝时，进行值传递，也就是将属性值复制一份新的。引用属性拷贝时，进行引用的拷贝，将拷贝出来的引用对象复制给新对象。
	深拷贝实现方式：
		1、重写clone方法
		2、通过对象的序列化
	使用实例：当SpringBean配置的作用域是property时，ApplicationContext.getBean() -> ApplicationContext.doGetBean() -> beanFactory.createBean()

适配器模式：
	类适配器：适配器类，继承需要被适配的对象，同时实现一个用来适配的接口，在适配器类中通过适配方法实现适配的过程。违背：迪米特法则
	对象适配器：将需要被适配的对象聚合到适配器类中，在适配器类中通过适配方法实现适配的过程。
	接口适配器：定义抽象父类，父类实现公共接口（都是空方法），在适配器类中通过匿名内部类对方法进行重写。违背：里氏替换原则
	使用实例：SpringMvc中的DispatcherServlet在处理请求是会找到对应的HandlerAdapter适配器（controller处理前会进行参数解析，controller处理后进行返回值解析）
	
装饰器模式：装饰者模式就是动态的将新功能附加到对象上。装饰者、被装饰者都继承自统一的基类，装饰者内部聚合被装饰者。
	被装饰者（Component）：奶茶、饮料；
	装饰者（Decorator）：比如西米、红豆、冰沙等。
	使用实例：IO模型下的FilterInputStream就是一个装饰着抽象类，其子类：ByteArrayInputStream、DataInputStream就是装饰类，可用于装饰FileInputStrem等

组合模式：树状接口，各层节点都继承自统一的抽象基类，除叶子节点外，其他层节点都聚合一个抽象类的集合用来管理元素。
	使用实例：Map、HashMap、HashMap内部的Node节点

享元模式：缓存技术、池技术等
	使用实例：锁升级的过程、Integer.valueOf("127")自动封装时，对于-128~127区间中的数值进行了缓存。
 
代理模式：
	静态代理：需要定义接口或者父类，被代理对象和代理对象一起实现相同的接口或者继承相同的父类。
	动态代理：代理对象不需要实现接口，被代理对象需要实现接口，利用JDK的API动态的在内存中通过反射构建代理对象。
		1、JDK动态代理，基于接口
		2、cglib动态代理：可以在内存中动态创建对象，而不需要实现接口

状态模式：
	1、状态接口类、相关的状态实体类实现状态接口类。
	2、状态控制类中合并所有的状态实体类，同时定义一个用户动态切换的状态变量。

策略模式：
	1、策略接口类、相关的策略实体类实现策略接口类。
	2、客户端聚合策略接口类，通过Java多态的特性在客户端指定不同的策略。
	使用实例：
		1、Arrays.sort在对数组排序的时候，支持传递不同的Comparetor比较策略。
		2、java8的lambda表达式

备忘录模式：在不破坏对象封装特性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。方便后期状态的恢复。
	1、Originator：需要保存的对象
	2、Memento：备忘录对象，负责保存Originator的内部状态
	3、Caretaker：守护者对象，负责保存多个备忘录对象Memento

访问者模式：在被访问者的类里面加一个对外提供接待访问者的接口

观察者模式：核心处理类WorkData中、以集合的方式管理用户Observer，包括用户的注册、移除、通知
	使用实例：JDK中的Observable类使用的就是观察者模式